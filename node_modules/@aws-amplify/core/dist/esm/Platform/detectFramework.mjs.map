{"version":3,"file":"detectFramework.mjs","sources":["../../../src/Platform/detectFramework.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Framework } from './types';\nimport { detect } from './detection';\n// We want to cache detection since the framework won't change\nlet frameworkCache;\nexport const frameworkChangeObservers = [];\n// Setup the detection reset tracking / timeout delays\nlet resetTriggered = false;\nconst SSR_RESET_TIMEOUT = 10; // ms\nconst WEB_RESET_TIMEOUT = 10; // ms\nconst PRIME_FRAMEWORK_DELAY = 1000; // ms\nexport const detectFramework = () => {\n    if (!frameworkCache) {\n        frameworkCache = detect();\n        if (resetTriggered) {\n            // The final run of detectFramework:\n            // Starting from this point, the `frameworkCache` becomes \"final\".\n            // So we don't need to notify the observers again so the observer\n            // can be removed after the final notice.\n            while (frameworkChangeObservers.length) {\n                frameworkChangeObservers.pop()?.();\n            }\n        }\n        else {\n            // The first run of detectFramework:\n            // Every time we update the cache, call each observer function\n            frameworkChangeObservers.forEach(fcn => {\n                fcn();\n            });\n        }\n        // Retry once for either Unknown type after a delay (explained below)\n        resetTimeout(Framework.ServerSideUnknown, SSR_RESET_TIMEOUT);\n        resetTimeout(Framework.WebUnknown, WEB_RESET_TIMEOUT);\n    }\n    return frameworkCache;\n};\n/**\n * @internal Setup observer callback that will be called everytime the framework changes\n */\nexport const observeFrameworkChanges = (fcn) => {\n    // When the `frameworkCache` won't be updated again, we ignore all incoming\n    // observers.\n    if (resetTriggered) {\n        return;\n    }\n    frameworkChangeObservers.push(fcn);\n};\nexport function clearCache() {\n    frameworkCache = undefined;\n}\n// For a framework type and a delay amount, setup the event to re-detect\n//   During the runtime boot, it is possible that framework detection will\n//   be triggered before the framework has made modifications to the\n//   global/window/etc needed for detection. When no framework is detected\n//   we will reset and try again to ensure we don't use a cached\n//   non-framework detection result for all requests.\nfunction resetTimeout(framework, delay) {\n    if (frameworkCache === framework && !resetTriggered) {\n        setTimeout(() => {\n            clearCache();\n            resetTriggered = true;\n            setTimeout(detectFramework, PRIME_FRAMEWORK_DELAY);\n        }, delay);\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AAGA;AACA,IAAI,cAAc;AACN,MAAC,wBAAwB,GAAG;AACxC;AACA,IAAI,cAAc,GAAG,KAAK;AAC1B,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAC7B,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAC7B,MAAM,qBAAqB,GAAG,IAAI,CAAC;AACvB,MAAC,eAAe,GAAG,MAAM;AACrC,IAAI,IAAI,CAAC,cAAc,EAAE;AACzB,QAAQ,cAAc,GAAG,MAAM,EAAE;AACjC,QAAQ,IAAI,cAAc,EAAE;AAC5B;AACA;AACA;AACA;AACA,YAAY,OAAO,wBAAwB,CAAC,MAAM,EAAE;AACpD,gBAAgB,wBAAwB,CAAC,GAAG,EAAE,IAAI;AAClD;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,wBAAwB,CAAC,OAAO,CAAC,GAAG,IAAI;AACpD,gBAAgB,GAAG,EAAE;AACrB,aAAa,CAAC;AACd;AACA;AACA,QAAQ,YAAY,CAAC,SAAS,CAAC,iBAAiB,EAAE,iBAAiB,CAAC;AACpE,QAAQ,YAAY,CAAC,SAAS,CAAC,UAAU,EAAE,iBAAiB,CAAC;AAC7D;AACA,IAAI,OAAO,cAAc;AACzB;AACA;AACA;AACA;AACY,MAAC,uBAAuB,GAAG,CAAC,GAAG,KAAK;AAChD;AACA;AACA,IAAI,IAAI,cAAc,EAAE;AACxB,QAAQ;AACR;AACA,IAAI,wBAAwB,CAAC,IAAI,CAAC,GAAG,CAAC;AACtC;AACO,SAAS,UAAU,GAAG;AAC7B,IAAI,cAAc,GAAG,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,YAAY,CAAC,SAAS,EAAE,KAAK,EAAE;AACxC,IAAI,IAAI,cAAc,KAAK,SAAS,IAAI,CAAC,cAAc,EAAE;AACzD,QAAQ,UAAU,CAAC,MAAM;AACzB,YAAY,UAAU,EAAE;AACxB,YAAY,cAAc,GAAG,IAAI;AACjC,YAAY,UAAU,CAAC,eAAe,EAAE,qBAAqB,CAAC;AAC9D,SAAS,EAAE,KAAK,CAAC;AACjB;AACA;;;;"}